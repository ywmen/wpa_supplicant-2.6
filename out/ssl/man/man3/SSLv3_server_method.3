.rn '' }`
''' $RCSfile$$Revision$$Date$
'''
''' $Log$
'''
.de Sh
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp
.if t .sp .5v
.if n .sp
..
.de Ip
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb
.ft CW
.nf
.ne \\$1
..
.de Ve
.ft R

.fi
..
'''
'''
'''     Set up \*(-- to give an unbreakable dash;
'''     string Tr holds user defined translation string.
'''     Bell System Logo is used as a dummy character.
'''
.tr \(*W-|\(bv\*(Tr
.ie n \{\
.ds -- \(*W-
.ds PI pi
.if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\" diablo 12 pitch
.ds L" ""
.ds R" ""
'''   \*(M", \*(S", \*(N" and \*(T" are the equivalent of
'''   \*(L" and \*(R", except that they are used on ".xx" lines,
'''   such as .IP and .SH, which do another additional levels of
'''   double-quote interpretation
.ds M" """
.ds S" """
.ds N" """""
.ds T" """""
.ds L' '
.ds R' '
.ds M' '
.ds S' '
.ds N' '
.ds T' '
'br\}
.el\{\
.ds -- \(em\|
.tr \*(Tr
.ds L" ``
.ds R" ''
.ds M" ``
.ds S" ''
.ds N" ``
.ds T" ''
.ds L' `
.ds R' '
.ds M' `
.ds S' '
.ds N' `
.ds T' '
.ds PI \(*p
'br\}
.\"	If the F register is turned on, we'll generate
.\"	index entries out stderr for the following things:
.\"		TH	Title 
.\"		SH	Header
.\"		Sh	Subsection 
.\"		Ip	Item
.\"		X<>	Xref  (embedded
.\"	Of course, you have to process the output yourself
.\"	in some meaninful fashion.
.if \nF \{
.de IX
.tm Index:\\$1\t\\n%\t"\\$2"
..
.nr % 0
.rr F
.\}
.TH SSL_CTX_new 3 "1.0.1s" "1/Mar/2016" "OpenSSL"
.UC
.if n .hy 0
.if n .na
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.de CQ          \" put $1 in typewriter font
.ft CW
'if n "\c
'if t \\&\\$1\c
'if n \\&\\$1\c
'if n \&"
\\&\\$2 \\$3 \\$4 \\$5 \\$6 \\$7
'.ft R
..
.\" @(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2
.	\" AM - accent mark definitions
.bd B 3
.	\" fudge factors for nroff and troff
.if n \{\
.	ds #H 0
.	ds #V .8m
.	ds #F .3m
.	ds #[ \f1
.	ds #] \fP
.\}
.if t \{\
.	ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.	ds #V .6m
.	ds #F 0
.	ds #[ \&
.	ds #] \&
.\}
.	\" simple accents for nroff and troff
.if n \{\
.	ds ' \&
.	ds ` \&
.	ds ^ \&
.	ds , \&
.	ds ~ ~
.	ds ? ?
.	ds ! !
.	ds /
.	ds q
.\}
.if t \{\
.	ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.	ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.	ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.	ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.	ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.	ds ? \s-2c\h'-\w'c'u*7/10'\u\h'\*(#H'\zi\d\s+2\h'\w'c'u*8/10'
.	ds ! \s-2\(or\s+2\h'-\w'\(or'u'\v'-.8m'.\v'.8m'
.	ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.	ds q o\h'-\w'o'u*8/10'\s-4\v'.4m'\z\(*i\v'-.4m'\s+4\h'\w'o'u*8/10'
.\}
.	\" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds v \\k:\h'-(\\n(.wu*9/10-\*(#H)'\v'-\*(#V'\*(#[\s-4v\s0\v'\*(#V'\h'|\\n:u'\*(#]
.ds _ \\k:\h'-(\\n(.wu*9/10-\*(#H+(\*(#F*2/3))'\v'-.4m'\z\(hy\v'.4m'\h'|\\n:u'
.ds . \\k:\h'-(\\n(.wu*8/10)'\v'\*(#V*4/10'\z.\v'-\*(#V*4/10'\h'|\\n:u'
.ds 3 \*(#[\v'.2m'\s-2\&3\s0\v'-.2m'\*(#]
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.ds oe o\h'-(\w'o'u*4/10)'e
.ds Oe O\h'-(\w'O'u*4/10)'E
.	\" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.	\" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.	ds : e
.	ds 8 ss
.	ds v \h'-1'\o'\(aa\(ga'
.	ds _ \h'-1'^
.	ds . \h'-1'.
.	ds 3 3
.	ds o a
.	ds d- d\h'-1'\(ga
.	ds D- D\h'-1'\(hy
.	ds th \o'bp'
.	ds Th \o'LP'
.	ds ae ae
.	ds Ae AE
.	ds oe oe
.	ds Oe OE
.\}
.rm #[ #] #H #V #F C
.SH "NAME"
SSL_CTX_new,
SSLv23_method, SSLv23_server_method, SSLv23_client_method,
TLSv1_2_method, TLSv1_2_server_method, TLSv1_2_client_method,
TLSv1_1_method, TLSv1_1_server_method, TLSv1_1_client_method,
TLSv1_method, TLSv1_server_method, TLSv1_client_method,
SSLv3_method, SSLv3_server_method, SSLv3_client_method,
SSLv2_method, SSLv2_server_method, SSLv2_client_method,
DTLSv1_method, DTLSv1_server_method, DTLSv1_client_method \-
create a new SSL_CTX object as framework for TLS/SSL enabled functions
.SH "SYNOPSIS"
.PP
.Vb 1
\& #include <openssl/ssl.h>
.Ve
.Vb 23
\& SSL_CTX *SSL_CTX_new(const SSL_METHOD *method);
\& const SSL_METHOD *SSLv23_method(void);
\& const SSL_METHOD *SSLv23_server_method(void);
\& const SSL_METHOD *SSLv23_client_method(void);
\& const SSL_METHOD *TLSv1_2_method(void);
\& const SSL_METHOD *TLSv1_2_server_method(void);
\& const SSL_METHOD *TLSv1_2_client_method(void);
\& const SSL_METHOD *TLSv1_1_method(void);
\& const SSL_METHOD *TLSv1_1_server_method(void);
\& const SSL_METHOD *TLSv1_1_client_method(void);
\& const SSL_METHOD *TLSv1_method(void);
\& const SSL_METHOD *TLSv1_server_method(void);
\& const SSL_METHOD *TLSv1_client_method(void);
\& #ifndef OPENSSL_NO_SSL3_METHOD
\& const SSL_METHOD *SSLv3_method(void);
\& const SSL_METHOD *SSLv3_server_method(void);
\& const SSL_METHOD *SSLv3_client_method(void);
\& #endif
\& #ifndef OPENSSL_NO_SSL2
\& const SSL_METHOD *SSLv2_method(void);
\& const SSL_METHOD *SSLv2_server_method(void);
\& const SSL_METHOD *SSLv2_client_method(void);
\& #endif
.Ve
.Vb 3
\& const SSL_METHOD *DTLSv1_method(void);
\& const SSL_METHOD *DTLSv1_server_method(void);
\& const SSL_METHOD *DTLSv1_client_method(void);
.Ve
.SH "DESCRIPTION"
\fISSL_CTX_new()\fR creates a new \fBSSL_CTX\fR object as framework to establish
TLS/SSL enabled connections.
.SH "NOTES"
The SSL_CTX object uses \fBmethod\fR as connection method. The methods exist
in a generic type (for client and server use), a server only type, and a
client only type. \fBmethod\fR can be of the following types:
.Ip "SSLv23_method(), SSLv23_server_method(), SSLv23_client_method()" 4
These are the general-purpose \fIversion-flexible\fR \s-1SSL/TLS\s0 methods.
The actual protocol version used will be negotiated to the highest version
mutually supported by the client and the server.
The supported protocols are SSLv2, SSLv3, TLSv1, TLSv1.1 and TLSv1.2.
Most applications should use these method, and avoid the version specific
methods described below.
.Sp
The list of protocols available can be further limited using the
\fBSSL_OP_NO_SSLv2\fR, \fBSSL_OP_NO_SSLv3\fR, \fBSSL_OP_NO_TLSv1\fR,
\fBSSL_OP_NO_TLSv1_1\fR and \fBSSL_OP_NO_TLSv1_2\fR options of the
the \fISSL_CTX_set_options(3)\fR manpage or the \fISSL_set_options(3)\fR manpage functions.
Clients should avoid creating \*(L"holes\*(R" in the set of protocols they support,
when disabling a protocol, make sure that you also disable either all previous
or all subsequent protocol versions.
In clients, when a protocol version is disabled without disabling \fIall\fR
previous protocol versions, the effect is to also disable all subsequent
protocol versions.
.Sp
The SSLv2 and SSLv3 protocols are deprecated and should generally not be used.
Applications should typically use the \fISSL_CTX_set_options(3)\fR manpage in combination with
the \fBSSL_OP_NO_SSLv3\fR flag to disable negotiation of SSLv3 via the above
\fIversion-flexible\fR \s-1SSL/TLS\s0 methods.
The \fBSSL_OP_NO_SSLv2\fR option is set by default, and would need to be cleared
via the \fISSL_CTX_clear_options(3)\fR manpage in order to enable negotiation of SSLv2.
.Ip "TLSv1_2_method(), TLSv1_2_server_method(), TLSv1_2_client_method()" 4
A \s-1TLS/SSL\s0 connection established with these methods will only understand the
TLSv1.2 protocol.  A client will send out TLSv1.2 client hello messages and
will also indicate that it only understand TLSv1.2.  A server will only
understand TLSv1.2 client hello messages.
.Ip "TLSv1_1_method(), TLSv1_1_server_method(), TLSv1_1_client_method()" 4
A \s-1TLS/SSL\s0 connection established with these methods will only understand the
TLSv1.1 protocol.  A client will send out TLSv1.1 client hello messages and
will also indicate that it only understand TLSv1.1.  A server will only
understand TLSv1.1 client hello messages.
.Ip "TLSv1_method(), TLSv1_server_method(), TLSv1_client_method()" 4
A \s-1TLS/SSL\s0 connection established with these methods will only understand the
TLSv1 protocol.  A client will send out TLSv1 client hello messages and will
indicate that it only understands TLSv1.  A server will only understand TLSv1
client hello messages.
.Ip "SSLv3_method(), SSLv3_server_method(), SSLv3_client_method()" 4
A \s-1TLS/SSL\s0 connection established with these methods will only understand the
SSLv3 protocol.  A client will send out SSLv3 client hello messages and will
indicate that it only understands SSLv3.  A server will only understand SSLv3
client hello messages.  The SSLv3 protocol is deprecated and should not be
used.
.Ip "SSLv2_method(), SSLv2_server_method(), SSLv2_client_method()" 4
A \s-1TLS/SSL\s0 connection established with these methods will only understand the
SSLv2 protocol.  A client will send out SSLv2 client hello messages and will
also indicate that it only understand SSLv2.  A server will only understand
SSLv2 client hello messages.  The SSLv2 protocol offers little to no security
and should not be used.
As of OpenSSL 1.0.1s, \s-1EXPORT\s0 ciphers and 56-bit \s-1DES\s0 are no longer available
with SSLv2.
.Ip "DTLSv1_method(), DTLSv1_server_method(), DTLSv1_client_method()" 4
These are the version-specific methods for DTLSv1.
.PP
\fISSL_CTX_new()\fR initializes the list of ciphers, the session cache setting, the
callbacks, the keys and certificates and the options to its default values.
.SH "RETURN VALUES"
The following return values can occur:
.Ip "\s-1NULL\s0" 4
The creation of a new \s-1SSL_CTX\s0 object failed. Check the error stack to find out
the reason.
.Ip "Pointer to an \s-1SSL_CTX\s0 object" 4
The return value points to an allocated \s-1SSL_CTX\s0 object.
.SH "SEE ALSO"
the \fISSL_CTX_set_options(3)\fR manpage, the \fISSL_CTX_clear_options(3)\fR manpage, the \fISSL_set_options(3)\fR manpage,
SSL_CTX_free(3), SSL_accept(3),
ssl(3),  SSL_set_connect_state(3)

.rn }` ''
.IX Title "SSL_CTX_new 3"
.IX Name "SSL_CTX_new, SSLv23_method, SSLv23_server_method, SSLv23_client_method, TLSv1_2_method, TLSv1_2_server_method, TLSv1_2_client_method, TLSv1_1_method, TLSv1_1_server_method, TLSv1_1_client_method, TLSv1_method, TLSv1_server_method, TLSv1_client_method, SSLv3_method, SSLv3_server_method, SSLv3_client_method, SSLv2_method, SSLv2_server_method, SSLv2_client_method, DTLSv1_method, DTLSv1_server_method, DTLSv1_client_method - create a new SSL_CTX object as framework for TLS/SSL enabled functions"

.IX Header "NAME"

.IX Header "SYNOPSIS"

.IX Header "DESCRIPTION"

.IX Header "NOTES"

.IX Item "SSLv23_method(), SSLv23_server_method(), SSLv23_client_method()"

.IX Item "TLSv1_2_method(), TLSv1_2_server_method(), TLSv1_2_client_method()"

.IX Item "TLSv1_1_method(), TLSv1_1_server_method(), TLSv1_1_client_method()"

.IX Item "TLSv1_method(), TLSv1_server_method(), TLSv1_client_method()"

.IX Item "SSLv3_method(), SSLv3_server_method(), SSLv3_client_method()"

.IX Item "SSLv2_method(), SSLv2_server_method(), SSLv2_client_method()"

.IX Item "DTLSv1_method(), DTLSv1_server_method(), DTLSv1_client_method()"

.IX Header "RETURN VALUES"

.IX Item "\s-1NULL\s0"

.IX Item "Pointer to an \s-1SSL_CTX\s0 object"

.IX Header "SEE ALSO"

